import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import yaml
import json
from datetime import datetime, timedelta
from pathlib import Path
import logging
from twilio.rest import Client

class AlertSystem:
    def __init__(self, config_file='alert_config.yaml'):
        self.config_file = Path(config_file)
        self.config = self.load_config()
        self.alert_history = []
        self.last_alert_time = None
        self.setup_logging()

    def load_config(self):
        if self.config_file.exists():
            with open(self.config_file, 'r') as f:
                return yaml.safe_load(f)
        else:
            # Default config
            return {
                'alerts': {
                    'email': {'enabled': False},
                    'sms': {'enabled': False},
                    'thresholds': {'high_risk': 70, 'medium_risk': 50, 'low_risk': 30},
                    'cooldown_minutes': 60
                }
            }

    def setup_logging(self):
        self.logger = logging.getLogger('AlertSystem')
        self.logger.setLevel(logging.INFO)
        handler = logging.FileHandler('logs/alert_system.log')
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)

    def check_cooldown(self):
        """Check if enough time has passed since last alert"""
        if self.last_alert_time is None:
            return True

        cooldown_period = timedelta(minutes=self.config['alerts']['cooldown_minutes'])
        return datetime.now() - self.last_alert_time > cooldown_period

    def send_email_alert(self, risk_score, company_info, prediction_details):
        """Send email alert for high-risk predictions"""
        if not self.config['alerts']['email'].get('enabled', False):
            return False

        try:
            msg = MIMEMultipart()
            msg['From'] = self.config['alerts']['email']['sender_email']
            msg['To'] = ', '.join(self.config['alerts']['email']['recipients'])
            msg['Subject'] = f"ðŸš¨ HIGH BREACH RISK ALERT - {company_info.get('name', 'Unknown Company')}"

            risk_level = "HIGH" if risk_score >= self.config['alerts']['thresholds']['high_risk'] else "MEDIUM"

            body = f"""
            BREACH PREDICTION ALERT

            Risk Level: {risk_level}
            Risk Score: {risk_score:.1f}%

            Company Information:
            - Name: {company_info.get('name', 'N/A')}
            - Industry: {company_info.get('industry', 'N/A')}
            - Size: {company_info.get('size', 'N/A')}

            Prediction Details:
            {json.dumps(prediction_details, indent=2)}

            Immediate action recommended for risk scores above 70%.

            Generated by AI Breach Predictor System
            {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
            """

            msg.attach(MIMEText(body, 'plain'))

            server = smtplib.SMTP(self.config['alerts']['email']['smtp_server'],
                                self.config['alerts']['email']['smtp_port'])
            server.starttls()
            server.login(self.config['alerts']['email']['sender_email'],
                        self.config['alerts']['email']['sender_password'])
            text = msg.as_string()
            server.sendmail(self.config['alerts']['email']['sender_email'],
                          self.config['alerts']['email']['recipients'], text)
            server.quit()

            self.logger.info(f"Email alert sent for risk score: {risk_score}")
            return True

        except Exception as e:
            self.logger.error(f"Failed to send email alert: {str(e)}")
            return False

    def send_sms_alert(self, risk_score, company_info):
        """Send SMS alert for critical predictions"""
        if not self.config['alerts']['sms'].get('enabled', False):
            return False

        try:
            client = Client(self.config['alerts']['sms']['twilio_account_sid'],
                          self.config['alerts']['sms']['twilio_auth_token'])

            risk_level = "CRITICAL" if risk_score >= 80 else "HIGH"

            message = f"""ðŸš¨ BREACH ALERT: {company_info.get('name', 'Company')} at {risk_score:.0f}% risk.
            Immediate review required."""

            for recipient in self.config['alerts']['sms']['recipients']:
                client.messages.create(
                    body=message,
                    from_=self.config['alerts']['sms']['twilio_phone_number'],
                    to=recipient
                )

            self.logger.info(f"SMS alert sent for risk score: {risk_score}")
            return True

        except Exception as e:
            self.logger.error(f"Failed to send SMS alert: {str(e)}")
            return False

    def trigger_alert(self, risk_score, company_info, prediction_details=None):
        """Main method to trigger alerts based on risk score"""
        if prediction_details is None:
            prediction_details = {}

        thresholds = self.config['alerts']['thresholds']

        # Only alert for medium or high risk
        if risk_score < thresholds['medium_risk']:
            return False

        # Check cooldown
        if not self.check_cooldown():
            self.logger.info(f"Alert cooldown active, skipping alert for risk score: {risk_score}")
            return False

        alert_sent = False

        # Send email alert
        if self.send_email_alert(risk_score, company_info, prediction_details):
            alert_sent = True

        # Send SMS for very high risk
        if risk_score >= thresholds['high_risk']:
            if self.send_sms_alert(risk_score, company_info):
                alert_sent = True

        if alert_sent:
            self.last_alert_time = datetime.now()
            self.alert_history.append({
                'timestamp': datetime.now().isoformat(),
                'risk_score': risk_score,
                'company': company_info,
                'alert_types': ['email'] if risk_score < 80 else ['email', 'sms']
            })

        return alert_sent

    def get_alert_history(self):
        """Get recent alert history"""
        return self.alert_history[-10:]  # Last 10 alerts

    def get_active_alerts(self):
        """Get active alerts (alerts from the last 24 hours)"""
        if not self.alert_history:
            return []

        # Get alerts from the last 24 hours
        cutoff_time = datetime.now() - timedelta(hours=24)
        active_alerts = [
            alert for alert in self.alert_history
            if datetime.fromisoformat(alert['timestamp']) > cutoff_time
        ]
        return active_alerts

    def send_alert(self, message, alert_type='general'):
        """Send a simple alert message"""
        if not self.check_cooldown():
            self.logger.info(f"Alert cooldown active, skipping alert: {message}")
            return False

        alert_sent = False

        # Send email alert
        if self.config['alerts']['email'].get('enabled', False):
            try:
                msg = MIMEMultipart()
                msg['From'] = self.config['alerts']['email']['sender_email']
                msg['To'] = ', '.join(self.config['alerts']['email']['recipients'])
                msg['Subject'] = f"ðŸš¨ ALERT - {alert_type.upper()}"

                body = f"""
                ALERT NOTIFICATION

                Type: {alert_type.upper()}
                Message: {message}

                Generated by AI Breach Predictor System
                {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
                """

                msg.attach(MIMEText(body, 'plain'))

                server = smtplib.SMTP(self.config['alerts']['email']['smtp_server'],
                                    self.config['alerts']['email']['smtp_port'])
                server.starttls()
                server.login(self.config['alerts']['email']['sender_email'],
                            self.config['alerts']['email']['sender_password'])
                text = msg.as_string()
                server.sendmail(self.config['alerts']['email']['sender_email'],
                              self.config['alerts']['email']['recipients'], text)
                server.quit()

                self.logger.info(f"Email alert sent: {message}")
                alert_sent = True

            except Exception as e:
                self.logger.error(f"Failed to send email alert: {str(e)}")

        # Send SMS alert for critical alerts
        if alert_type.lower() in ['critical', 'dark_web_threat'] and self.config['alerts']['sms'].get('enabled', False):
            try:
                client = Client(self.config['alerts']['sms']['twilio_account_sid'],
                              self.config['alerts']['sms']['twilio_auth_token'])

                sms_message = f"ðŸš¨ ALERT: {message[:160]}"  # SMS length limit

                for recipient in self.config['alerts']['sms']['recipients']:
                    client.messages.create(
                        body=sms_message,
                        from_=self.config['alerts']['sms']['twilio_phone_number'],
                        to=recipient
                    )

                self.logger.info(f"SMS alert sent: {message}")
                alert_sent = True

            except Exception as e:
                self.logger.error(f"Failed to send SMS alert: {str(e)}")

        if alert_sent:
            self.last_alert_time = datetime.now()
            self.alert_history.append({
                'timestamp': datetime.now().isoformat(),
                'message': message,
                'alert_type': alert_type,
                'alert_types': ['email'] if alert_type.lower() != 'critical' else ['email', 'sms']
            })

        return alert_sent

    def update_config(self, new_config):
        """Update alert configuration"""
        self.config = new_config
        with open(self.config_file, 'w') as f:
            yaml.dump(self.config, f)
        self.logger.info("Alert configuration updated")
